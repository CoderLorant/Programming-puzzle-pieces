<h3>9. Unit Tests</h3>
<b>The Three Laws of TDD</b><br/>
"TDD asks us to write unit tests first, before we write production code."
<br/><br/>
<b>First Law</b> You may not write production code until you have written a filing unit test.
<br/><br/>
<b>Second Law</b> You may not write more of a unit test than is sufficient to fail, and not compiling is failing.
<br/><br/>
<b>Third Law</b> You may not write more production code than is sufficient to pass the currently failing test.
<br/><br/>
"The tests and the production code are written together, with the tests just a few seconds ahead of the production code."
<br/><br/>
"If we work this way, those tests will cover virtually all of our production code."
<br/><br/>
<b>Keeping Tests Clean</b><br/>
"having dirty tests is equivalent, if not worse than, having no tests. The problem is that tests must change as the production code evolves. The dirtier the tests, the harder they are to change."
<br/><br/>
"Test code is just as important as production code. It is not a second-class citizen. It requires thought, design, and care. It must be kept as clean as production code."
<br/><br/>
<b>Tests Enable the -ilities</b><br/>
"It is unit tests that keep our code flexible, maintainable, and reusable. The reason is simple. If you have tests, you do not fear making changes to the code! Without tests every change is a possible bug."
<br/><br/>
"The higher your test coverage, the less you fear."
<br/><br/>
"So having an automated suite of unit tests that cover the production code is the key to keeping your design and architecture as clean as possible. Tests enable all the -illities, because tests enable change."
<br/><br/>
"The dirtier your tests, the dirtier your code becomes. Eventually you lose the tests, and your code rots."
<br/><br/>
<b>Clean Tests</b><br/>
"What makes a clean test? Three things. Readability, readability, and readability. Readability is perhaps even more important in unit tests than it is in production code. What makes tests readable? The same thing that makes all code readable: clarity, simplicity, and density of expression."
<br/><br/>
[In this chapter there is an example about how to craft your own functions and use them in tests in order to make tests more easier to understand at first look.]
<br/><br/>
<b>Domain-Specific Testing Language</b><br/>
"Rather than using the APIs that programmers use to manipulate the system, we build up a set of functions and utilities that make use of those APIs and that make the tests more convenient to write and easier to read."
<br/><br/>
"This testing API is not designed up front; rather it evolves from the continued refactoring of test code that has gotten too tainted by obfuscating detail."
<br/><br/>
<b>A Dual Standard</b><br/>
"The code within the testing API does have a different set of engineering standards than production code. It must still be simple, succinct, and expressive, but it need not be as sufficient as production code."
<br/><br/>
[There is an example in this section, consider searching it if you are curious - page 128]
<br/><br/>
"There are things that you might never do in a production environment that are perfectly fine in a test environment. Usually they involve issues of memory or CPU efficiency. But they never involve issues of cleanliness."
<br/><br/>
<b>One Assert per Test</b><br/>
"I think the single assert rule is a good guideline. I usually try to create a domain-specific testing language that supports it [...]. But I am not afraid to put more than one assert in a test. I think the best thing we can say is that the number of asserts in a test ought to be minimized."
<br/><br/>
<b>Single Concept per Test</b><br/>
"Perhaps a better rule is that we want to test a single concept in each test function. We don't want long test functions that go testing one miscellaneous thing after another."
<br/><br/>
"So probably the best rule is that you should minimize the number of asserts per concept and test just one concept per test function."
<br/><br/>
<b>F.I.R.S.T.</b><br/>
"Clean tests follow five other rules that form the above acronym:"
<br/><br/>
Fast Tests should be fast. They should run quickly. When tests run slow, you won't want to run them frequently. If you don't run them frequently, you won't find problems early enough to fix them easily. You won't feel as free to clean up the code. Eventually the code will begin to rot.
<br/><br/>
Independent Tests should not depend on each other. One test should not set up the conditions for the next test. You should be able to run each test independently and run the tests in any order you like. When tests depend on each other, then the first one fail causes a cascade of downstream failures, making diagnosis difficult and hiding downstream defects.
<br/><br/>
Repeatable Tests should be repeatable in any environment. You should be able to run the tests in the production environment, in the QA environment, and on your laptop while riding home on the train without a network. If your tests aren't repeatable in any environment, then you'll always have an excuse for why they fail. You'll also find yourself unable to run the tests when the environment isn't available.
<br/><br/>
Self-Validating The tests should have a boolean output. Either they pass or fail. You should not have to read through a log file to tell whether the tests pass. You should not have to manually compare two different text files to see whether the tests pass. If the tests aren't self-validating, then failure can become subjective and running the tests can require a long manual evaluation.
<br/><br/>
Timely The tests need to be written in a timely fashion. Unit tests should be written just before the production code that makes them pass. If you write tests after the production code, then you may find the production code to be hard to test. You may decide that some production code is too hard to test. You may not design the production code to be testable.